###### 3.13
1.  见：`c3\size.cpp`  ✔
> 可查看`<limits.h>`
2.  见：`c3\size.cpp`  ✔
> 可查看`<float.h>`


4. 长整型变量可能会被截断到短整型变量的长度，因为丢失相关数位导致运行的结果出错，但是程序仍能正常编译和运行。其他编译器不一定会导致结果出问题，因为长整型的位数可能等于短整型的位数。  ✔
5. 当把`double`变量赋值给`float`时，值可能被完整保留，也可能被截断尾数，甚至指数溢出。  ✔

6.

```c++
enum rmb{
    FEN = 1, JIAO = 10, YUAN = 100;
};
```
✔

8.不允许，见：`c3\str_mod.cpp`。不存在。✔
9.保证程序的可移植性和健壮性，因为在其他编译器上整型默认可能不是`signed`类型。  ✔
> 当整型用于存储字符时需要

12.前者是先声明后定义变量，后者是声明时直接定义变量。  ✔
13.将字面量赋值到常量符号上，并且常量符号定义在代码段而不是堆栈。❌
>```c++
> const int a = 25; // 正确，声明一个整型常量，同时为其初始化
> const int a; a = 25; // 错误，常量一旦声明，就不可修改其值 
>```

14.正确。在代码块内定义的变量作用域就是整个代码块，生命周期是执行这个代码块的时段。  ✔
15.错误。在代码块内定义的变量不会因为`extern`改变作用域和生命周期长度。  ✔
16.不变，仍然错误。使用`static`进行修饰只能改变其生命周期，使得这个变量在整个程序执行完之后才会失效，但是作用域仍然是所在的代码块内。  ✔
17.不需要。在整个文件开头定义的变量的链接属性默认是external，作用域是所有链接的文件，当然也包括定义该变量的文件。  ✔
18.不变。变量的链接属性变为internal，作用域是本文件，因此文件内的函数仍然能访问这个变量。  ✔
19.不需要。 ❌
>需要。若需要在其他源文件中使用该变量，必须显式加上`extern`修饰
 
20.会。需要在其他源文件添加
```c++
extern int x;
```
❌
>会。此时不能通过其他源文件访问该变量

22.出现在代码块内时，作用域限于这个代码块，生命周期限于这个代码块的执行期间。出现在任何代码块外部时，作用域为所有链接的源文件，生命周期从声明该变量到程序执行完毕。  ✔
23.
```c++
extern int a = 1;
static char b = 2;
void x(){
    int c = 3;
    static float d = 4;
}

void y(){
    int a = 5;
}
```
✔
24.  见：`c3\variables.cpp`
